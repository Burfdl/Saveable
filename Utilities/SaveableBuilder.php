<?php

	$expectedOptions = array(
		"all",
		"undo"
	);
	$options = array();
	$files = array();
	$index = 0;
	if ($argc <= 1)
	{
		echo "Usage: \n";
		echo "\tphp ".basename(__FILE__)." --all\n";
		echo "\t\tBuilds all files in the current directory (".getcwd().")\n";
		echo "\tphp ".basename(__FILE__)." FileToEdit.php [/path/to/file2 [../path/to/file3 ...]]\n";
		echo "\t\tBuilds specified files\n";
		echo "\tphp ".basename(__FILE__)." --undo [--all | FileToEdit.php]\n";
		echo "\t\tUndoes changes, attempting to leave clases in their original state\n";
		echo "\n";
		echo "Inserts a class (purely for autocompletion) into the class heirarchy between the named files and their parent class\n";
		echo "\n";
		echo "SaveableBuilder can only determine relationships between classes it can see.\n";
		echo "The more files built at once, the more complete the generated autocompletion superclasses will be.\n";
		die();
	}
	while (strpos(($param = $argv[++$index]), "-") === 0)
	{
		if (!in_array(($options[] = trim($param, "- ")), $expectedOptions))
		{
			die("Unexpected option '".$param."'\n");
		}
	}
	$index--;
	while (++$index < $argc)
	{
		$files[] = $argv[$index];
	}
	
	if (in_array("all", $options))
	{
		foreach (glob(getcwd()."/*") as $filename) {
			if (
				is_file($filename) && 
				!preg_match("/(^\.+$)|^_/i", basename($filename)) &&
				preg_match(
					"/class ([a-z0-9_-]+) extends (\/\*.+\*\/ )?([a-z0-9_-]+)/i", 
					file_get_contents($filename)
				)
			)
			{
				$files[] = $filename;
			}
		}
		
	}
	
	require_once(dirname(__FILE__)."/../DBM.php");
	require_once(dirname(__FILE__)."/Inflect.php");
	
	echo "Okay, So you want to ".(in_array("undo", $options) ? "un" : "")."build the following files: \n\n".implode("\n", $files)."\n\n";
	echo basename(__FILE__)." will edit the above files directly.\n";
	echo "Your files may be accidentally destroyed.\n";
	echo "Have you backed them up? [y/N]\n";
	$handle = fopen("php://stdin", "r");
	$response = fread($handle, 100);
	if (strpos(strtolower($response), "y") !== 0)
	{
		die("\nStopping!\n\n");
	}
	fclose($handle);
	echo "\n";
	
	$foundClasses = array();
	
	foreach ($files as $file)
	{
		$file = (strpos($file, "/") === 0 ? $file : getcwd()."/".$file);
		$before = get_declared_classes();
		require_once($file);
		$newClasses = array_diff(get_declared_classes(), $before);
		foreach ($newClasses as $newClass)
		{
			$reflection = new ReflectionClass($newClass);
			if (in_array($reflection->getFileName(), $files))
			{
				$foundClasses[] = $reflection;
			}
		}
	}
	
	// Inflate table names of classes if found
	$classTableNames = array();
	foreach ($foundClasses as /* @var $reflection ReflectionClass */ $reflection)
	{
		if (
			$reflection->isSubclassOf("Saveable") && 
			(
				$tableDef = call_user_func(
					array(
						$reflection->getName(), 
						"getTableDefinition"
					)
				)
			) instanceof TableDefinition &&
			strlen(
				$tableDef->getName()
			)
		)
		{
			$classTableNames[$reflection->getName()] = $tableDef->getName();
		}
	}
	
	// Inflate relations between classes
	$relations = array();
	foreach ($foundClasses as $reflection)
	{	/* @var $reflection ReflectionClass */ 
		$relations[$reflection->getName()] = array(
			"parents" => array(),
			"children" => array()
		);
		
		if (
			$reflection->isSubclassOf("Saveable") && 
			(
				/* @var $tableDef TableDefinition */
				$tableDef = call_user_func(
					array(
						$reflection->getName(), 
						"getTableDefinition"
					)
				)
			) instanceof TableDefinition
		)
		{
			foreach ($tableDef->getIndexes() as $index)
			{
				if ($index instanceof ForeignKeyDefinition)
				{
					if (
						in_array(
							$index->getForeignTableName(), 
							$classTableNames
						)
					)
					{
						$relations[$reflection->getName()]["parents"][] = 
							array_search(
								$index->getForeignTableName(), 
								$classTableNames
							);
					}
				}
			}
		}
	}
	
	// And now inflate the 'children' bits too
	foreach ($relations as $class => $rels)
	{
		foreach ($rels["parents"] as $parentRel)
		{
			$parentRel = $parentRel;
			if (!in_array($class, $relations[$parentRel]["children"]))
			{
				$relations[$parentRel]["children"][] = $class;
			}
		}
	}
	
	foreach ($foundClasses as $reflection)
	{	/* @var $reflection ReflectionClass */
		$extendingClass = null;
		if (
			file_exists(
				dirname($file)."/_".$reflection->getName().
						"__Autogenerated_By_SaveableBuilder.php"
			)
		)
		{
			$matches = array();
			if (
				preg_match(
					"/^\tabstract class _".$reflection->getName().
							"__Autogenerated_By_SaveableBuilder ".
							"extends (?P<extends>.+)$/m",
					file_get_contents(
						dirname($file)."/_".$reflection->getName().
								"__Autogenerated_By_SaveableBuilder.php"
					), 
					$matches
				)
			)
			{
				$extendingClass = $matches["extends"];
				if (
					$reflection->getParentClass()->getName() == 
						"_".$reflection->getName().
							"__Autogenerated_By_SaveableBuilder"
				)
				{
					$classContents = file_get_contents($reflection->getFileName());
					$classContents = str_replace(
						"class ".$reflection->getName()." extends /* ".
								$extendingClass." via */ _".
								$reflection->getName().
								"__Autogenerated_By_SaveableBuilder", 
						"class ".$reflection->getName()." extends ".
								$extendingClass,
						$classContents
					);
					$classContents = str_replace(
						"<?php require_once(dirname(__FILE__).\"/_".$reflection->getName()."__Autogenerated_By_SaveableBuilder.php\"); ?>\n", 
						"", 
						$classContents
					);
					$handle = fopen($reflection->getFileName(), "w");
					fwrite($handle, $classContents);
					fclose($handle);
					unlink(
						dirname($file)."/_".$reflection->getName().
								"__Autogenerated_By_SaveableBuilder.php"
					);
					if (file_exists(dirname($file)."/_".$reflection->getName()."__Collection__Autogenerated_By_SaveableBuilder.php"))
					{
						unlink(dirname($file)."/_".$reflection->getName()."__Collection__Autogenerated_By_SaveableBuilder.php");
					}
				}
				else if (
					$reflection->getParentClass()->getName() !== 
							"_".$reflection->getName().
							"__Autogenerated_By_SaveableBuilder"
				)
				{
					die("Class heirarchy has changed; ".$file." no ".
						"longer extends '_".$reflection->getName().
						"__Autogenerated_By_SaveableBuilder' -- ".
						"stopping execution here.");
				}
				else 
				{
					$extendingClass = $matches["extends"];
				}

			}
			else {
				die("Could not find what class _".
					$reflection->getName().
					"__Autogenerated_By_SaveableBuilder extends - ".
					"Stopped processing at ".$file);
			}
		}
		if ($extendingClass === null)
		{
			//$matches = array();
			$extendingClass = $reflection->getParentClass()->getName();
			/*if (
				preg_match(
					"/^(\t)?class ".$reflection->getName()." extends ".
						"(?P<extends>[^{]+)/m",
					file_get_contents($reflection->getFileName()), 
					$matches
				)
			)
			{
				$extendingClass = $matches["extends"];
			}
			else
			{
				die("Cannot find what class ".$reflection->getName().
					" extends -- Stopped processing at ".$file);
			}/**/
		}

		/* @var $object Saveable */
		if (!in_array("undo", $options))
		{
			if (
				(
					$tabledefinition = call_user_func(
						array(
							$reflection->getName(), 
							"getTableDefinition"
						)
					)
				) instanceof TableDefinition
			)
			{
				/* @var $tabledefinition TableDefinition */
				ob_start();
				echo "<?php\n";
				echo "\n";
				echo "\t/* WARNING: This file is autogenerated-- anything you edit may be overwritten */\n";
				echo "\t/* It is recommended that you edit '".basename($file)."' in stead */\n";
				echo "\n";
				echo "\trequire_once '_".$reflection->getName()."__Collection__Autogenerated_By_SaveableBuilder.php';\n";
				foreach ($relations[$reflection->getName()]["children"] as $childRel)
				{
					$relReflection = new ReflectionClass($childRel);
					if (dirname($reflection->getFileName()) == dirname($relReflection->getFileName()))
					{
						echo "\trequire_once '".basename($relReflection->getFileName())."';\n";
					}
				}
				foreach ($relations[$reflection->getName()]["parents"] as $parentRel)
				{
					$relReflection = new ReflectionClass($parentRel);
					if (dirname($reflection->getFileName()) == dirname($relReflection->getFileName()))
					{
						echo "\trequire_once '".basename($relReflection->getFileName())."';\n";
					}
				}
				echo "\n";
				echo "\tabstract class _".$reflection->getName()."__Autogenerated_By_SaveableBuilder extends ".$extendingClass."\n";
				echo "\t{\n";
				echo "\n";
				echo "\t\t/**\n";
				echo "\t\t * Attempts to save the ".$reflection->getName()."'s current state to the database.\n";
				echo "\t\t * @return ".$reflection->getName()."\n";
				echo "\t\t**/\n";
				echo "\t\tpublic function save(\$useCache = false)\n";
				echo "\t\t{\n";
				echo "\t\t\treturn parent::save(\$useCache);\n";
				echo "\t\t}\n";
				echo "\t\t\n";
				echo "\t\t/**\n";
				echo "\t\t * Uses the values currently set on this ".$reflection->getName()." to return a collection of all ".Inflect::pluralize($reflection->getName())." that match those values.\n";
				echo "\t\t * \n";
				echo "\t\t * @return _".$reflection->getName()."__Collection__Autogenerated_By_SaveableBuilder\n";
				echo "\t\t**/\n";
				echo "\t\tpublic function inflateCollection(\$useCache = false)\n";
				echo "\t\t{\n";
				echo "\t\t\treturn new _".$reflection->getName()."__Collection__Autogenerated_By_SaveableBuilder(parent::inflateCollection(\$useCache));\n";
				echo "\t\t}\n";
				if ($reflection->isSubclassOf("Deletable"))
				{
					echo "\t\t\n";
					echo "\t\t/**\n";
					echo "\t\t * @return ".$reflection->getName()."\n";
					echo "\t\t**/\n";
					echo "\t\tpublic function delete(\$useCache = false)\n";
					echo "\t\t{\n";
					echo "\t\t\treturn parent::delete(\$useCache);\n";
					echo "\t\t}\n";
				}
				foreach ($tabledefinition->getFieldNames() as $field)
				{
					if (
						call_user_func(
							array(
								$reflection->getName(),
								"isWritable"
							),
							$field
						)
					)
					{
						echo "\n";
						echo "\t\t/**\n";
						echo "\t\t * Sets a new value for ".$field."\n";
						echo "\t\t * \n";
						echo "\t\t * @param \$value\n";
						echo "\t\t * @return ".$reflection->getName()."\n";
						echo "\t\t**/\n";
						echo "\t\tpublic function set".$field."(\$value)\n";
						echo "\t\t{\n";
						echo "\t\t\tif (!\$this->getTableDefinition()->getField(\"".$field."\")->isValidValue(\$value))\n";
						echo "\t\t\t{\n";
						echo "\t\t\t\tthrow new Exception(\"'\".\$value.\"' is not a valid value for a ".Inflect::singularize($reflection->getName())."'s ".$field."\");\n";
						echo "\t\t\t}\n";
						echo "\t\t\t\$this->data[\"".$field."\"] = \$value;\n";
						echo "\t\t\treturn \$this;\n";
						echo "\t\t}\n";
					}
				}
				foreach ($tabledefinition->getFieldNames() as $field)
				{
					if (
						call_user_func(
							array(
								$reflection->getName(),
								"isReadable"
							),
							$field
						)
					)
					{
						echo "\n";
						echo "\t\t/**\n";
						echo "\t\t * Gets the current value for ".$field."\n";
						echo "\t\t**/\n";
						echo "\t\tpublic function get".$field."()\n";
						echo "\t\t{\n";
						echo "\t\t\treturn \$this->data[\"".$field."\"];\n";
						echo "\t\t}\n";
					}
				}
				echo "\n";
				echo "\t\t/**\n";
				echo "\t\t * Fetches and returns a collection of ".$reflection->getName()." objects returned by \n";
				echo "\t\t * the given query.\n";
				echo "\t\t * @param \$sql to send to the database\n";
				echo "\t\t * @return _".$reflection->getName()."__Collection__Autogenerated_By_SaveableBuilder\n";
				echo "\t\t**/\n";
				echo "\t\tpublic static function loadByQuery(\$sql, \$className = \"".$reflection->getName()."\")\n";
				echo "\t\t{\n";
				echo "\t\t\treturn new _".$reflection->getName()."__Collection__Autogenerated_By_Saveable(parent::loadByQuery(\$sql, ".$reflection->getName()."));\n";
				echo "\t\t}\n";
				echo "\n";
				echo "\t\t/**\n";
				echo "\t\t * Attempts to inflate the ".$reflection->getName().", assuming the currently \n"; 
				echo "\t\t * set fields will be unique enough to return only one result from the table.\n";
				echo "\t\t * \n";
				echo "\t\t * @param \$useCache\n";
				echo "\t\t * @return ".$reflection->getName()."\n";
				echo "\t\t**/\n";
				echo "\t\tpublic function inflate(\$useCache = false)\n";
				echo "\t\t{\n";
				echo "\t\t\treturn parent::inflate(\$useCache);\n";
				echo "\t\t}\n";
				echo "\n";
				echo "\t\t/**\n";
				echo "\t\t * Manufactures a new ".$reflection->getName()." for method chaining\n";
				echo "\t\t * \n";
				echo "\t\t * @param \$id\n";
				echo "\t\t * @param \$useCache\n";
				echo "\t\t * @return ".$reflection->getName()."\n";
				echo "\t\t**/\n";
				echo "\t\tpublic static function manufacture(\$id = false, \$useCache = false)\n";
				echo "\t\t{\n";
				echo "\t\t\treturn new ".$reflection->getName()."(\$id, \$useCache);\n";
				echo "\t\t}\n";
				foreach ($relations[$reflection->getName()]["children"] as $childRel)
				{
					echo "\t\n";
					echo "\t\t/**\n";
					echo "\t\t * Fetches and returns a collection of the ".Inflect::pluralize($childRel)." associated with this ".$reflection->getName()."\n";
					echo "\t\t * \n";
					echo "\t\t * @param boolean \$useCache\n";
					echo "\t\t * @return _".$childRel."__Collection__Autogenerated_By_SaveableBuilder\n";
					echo "\t\t**/\n";
					echo "\t\tpublic function fetch".Inflect::pluralize($childRel)."(\$useCache = false)\n";
					echo "\t\t{\n";
					echo "\t\t\treturn new _".$childRel."__Collection__Autogenerated_By_SaveableBuilder(\$this->getChildren(\"".$childRel."\", \$useCache));\n";
					echo "\t\t}\n";
				}
				foreach ($relations[$reflection->getName()]["parents"] as $parentRel)
				{
					echo "\t\n";
					echo "\t\t/**\n";
					echo "\t\t * Fetches parent ".$parentRel." for this ".$reflection->getName()."\n";
					echo "\t\t * \n";
					echo "\t\t * @param boolean \$useCache\n";
					echo "\t\t * @return ".$parentRel."\n";
					echo "\t\t**/\n";
					echo "\t\tpublic function fetch".$parentRel."(\$useCache = false)\n";
					echo "\t\t{\n";
					echo "\t\t\treturn \$this->getParent(\"".$parentRel."\", \$useCache);\n";
					echo "\t\t}\n";
				}
				echo "\t}\n";
				echo "\n";
				echo "?>";
				$handle = fopen(dirname($file)."/_".$reflection->getName()."__Autogenerated_By_SaveableBuilder.php", "w");
				fwrite($handle, ob_get_clean());
				fclose($handle);
				ob_start();
				echo "<?php\n";
				echo "\n";
				echo "\t/* WARNING: This file is autogenerated-- anything you edit may be overwritten */\n";
				echo "\t/* It is recommended that you edit '".basename($file)."' in stead */\n";
				echo "\n";
				echo "\tclass _".$reflection->getName()."__Collection__Autogenerated_By_SaveableBuilder extends ArrayObject\n";
				echo "\t{\n";
				echo "\t\n";
				echo "\t\tpublic function save()\n";
				echo "\t\t{\n";
				echo "\t\t\tforeach (\$this as \$index => \$item)\n";
				echo "\t\t\t{\n";
				echo "\t\t\t\t\$this[\$index] = \$item->save();\n";
				echo "\t\t\t}\n";
				echo "\t\t\treturn \$this;\n";
				echo "\t\t}\n";
				if ($reflection->isSubclassOf("Deletable"))
				{
					echo "\t\n";
					echo "\t\tpublic function delete()\n";
					echo "\t\t{\n";
					echo "\t\t\tforeach (\$this as \$index => \$item)\n";
					echo "\t\t\t{\n";
					echo "\t\t\t\t\$this[\$index] = \$item->delete();\n";
					echo "\t\t\t}\n";
					echo "\t\t\treturn \$this;\n";
					echo "\t\t}\n";	
				}
				foreach ($relations[$reflection->getName()]["children"] as $childRel)
				{
					echo "\t\t\n";
					echo "\t\t/**\n";
					echo "\t\t * Fetches and returns all ".Inflect::pluralize($childRel)." associated with these ".Inflect::pluralize($reflection->getName())."\n";
					echo "\t\t * \n";
					echo "\t\t * @return _".$childRel."__Collection__Autogenerated_By_SaveableBuilder\n";
					echo "\t\t**/\n";
					echo "\t\tfunction fetch".Inflect::pluralize($childRel)."(\$useCache = false)\n";
					echo "\t\t{\n";
					echo "\t\t\t\$returnable = array();\n";
					echo "\t\t\t\$knownkeys = array();\n";
					echo "\t\t\tforeach (\$this as \$item)\n";
					echo "\t\t\t{\n";
					echo "\t\t\t\tforeach (\$item->fetch".Inflect::pluralize($childRel)."(\$useCache) as \$found)\n";
					echo "\t\t\t\t{\n";
					echo "\t\t\t\t\tif (!in_array(\$found->getUniqueKey(), \$knownkeys))\n";
					echo "\t\t\t\t\t{\n";
					echo "\t\t\t\t\t\t\$returnable[] = \$found;\n";
					echo "\t\t\t\t\t\t\$knownkeys[] = \$found->getUniqueKey();\n";
					echo "\t\t\t\t\t}\n";
					echo "\t\t\t\t}\n";
					echo "\t\t\t}\n";
					echo "\t\t\treturn new _".$childRel."__Collection__Autogenerated_By_SaveableBuilder(\$returnable);\n";
					echo "\t\t}\n";
				}
				foreach ($relations[$reflection->getName()]["parents"] as $parentRel)
				{
					echo "\t\t\n";
					echo "\t\t/**\n";
					echo "\t\t * Fetches and returns all ".Inflect::pluralize($parentRel)." associated with these ".Inflect::pluralize($reflection->getName())."\n";
					echo "\t\t * \n";
					echo "\t\t * @return _".$parentRel."__Collection__Autogenerated_By_SaveableBuilder\n";
					echo "\t\t**/\n";
					echo "\t\tfunction fetch".$parentRel."(\$useCache = false)\n";
					echo "\t\t{\n";
					echo "\t\t\t\$returnable = new _".$parentRel."__Collection__Autogenerated_By_SaveableBuilder();\n";
					echo "\t\t\tforeach (\$this as \$item)\n";
					echo "\t\t\t{\n";
					echo "\t\t\t\t\$returnable[] = \$item->fetch".Inflect::pluralize($parentRel)."(\$useCache);\n";
					echo "\t\t\t}\n";
					echo "\t\t\treturn \$returnable;\n";
					echo "\t\t}\n";
				}
				foreach ($tabledefinition->getFieldNames() as $field)
				{
					if (
						call_user_func(
							array(
								$reflection->getName(),
								"isReadable"
							),
							$field
						)
					)
					{
						echo "\t\t\n";
						echo "\t\t/**\n";
						echo "\t\t * Sorts the ".$reflection->getName()." objects on the ".$field." field\n";
						echo "\t\t * \n";
						echo "\t\t * @param \$isAscendingOrder\n";
						echo "\t\t**/\n";
						echo "\t\tpublic function sortBy".$field."(\$isAscendingOrder = true)\n";
						echo "\t\t{\n";
						echo "\t\t\t\$sortKeys = array();\n";
						echo "\t\t\t\$dataKeys = \$this->exchangeArray(array());\n";
						echo "\t\t\tforeach (\$dataKeys as \$data)\n";
						echo "\t\t\t{\n";
						echo "\t\t\t\t\$sortKeys[] = \$data->get".$field."();\n";
						echo "\t\t\t}\n";
						echo "\t\t\tarray_multisort(\$sortKeys, (\$isAscendingOrder ? SORT_ASC : SORT_DESC), \$dataKeys, (\$isAscendingOrder ? SORT_ASC : SORT_DESC));\n";
						echo "\t\t\t\$this->exchangeArray(\$dataKeys);\n";
						echo "\t\t\treturn \$this;\n";
						echo "\t\t}\n";
						echo "\t\t\n";
						echo "\t\t/**\n";
						echo "\t\t * Filters the collection to only contain ".Inflect::pluralize($reflection->getName())." where the field '".$field."' matches the given value(s)\n";
						echo "\t\t * To include multiple items, list multiple parameters eg: \$x->filterOn".$field."Equals('x', 'y', 'z')\n";
						echo "\t\t * \n";
						echo "\t\t * @var mixed \$value\n";
						echo "\t\t**/\n";
						echo "\t\tpublic function filterOn".$field."Equals()\n";
						echo "\t\t{\n";
						echo "\t\t\t\$array = \$this->getArrayCopy(array());\n";
						echo "\t\t\t\$cleanArray = array();\n";
						echo "\t\t\t\$args = func_get_args();\n";
						echo "\t\t\tforeach (\$array as \$item)\n";
						echo "\t\t\t{\n";
						echo "\t\t\t\tif (in_array(\$item->get".$field."(), \$args))\n";
						echo "\t\t\t\t{\n";
						echo "\t\t\t\t\t\$cleanArray[] = \$item;";
						echo "\t\t\t\t}\n";
						echo "\t\t\t}\n";
						echo "\t\t\treturn new _".$reflection->getName()."__Collection__Autogenerated_By_SaveableBuilder(\$cleanArray);\n";
						echo "\t\t}\n";
						echo "\t\t\n";
						echo "\t\t/**\n";
						echo "\t\t * Filters the collection to remove ".Inflect::pluralize($reflection->getName())." where the field '".$field."' matches the given value(s)\n";
						echo "\t\t * To remove multiple items, list multiple parameters eg: \$x->filterOn".$field."NotEquals('x', 'y', 'z')\n";
						echo "\t\t * \n";
						echo "\t\t * @var mixed \$value\n";
						echo "\t\t**/\n";
						echo "\t\tpublic function filterOn".$field."NotEquals()\n";
						echo "\t\t{\n";
						echo "\t\t\t\$array = \$this->getArrayCopy(array());\n";
						echo "\t\t\t\$cleanArray = array();\n";
						echo "\t\t\t\$args = func_get_args();\n";
						echo "\t\t\tforeach (\$array as \$item)\n";
						echo "\t\t\t{\n";
						echo "\t\t\t\tif (!in_array(\$item->get".$field."(), \$args))\n";
						echo "\t\t\t\t{\n";
						echo "\t\t\t\t\t\$cleanArray[] = \$item;";
						echo "\t\t\t\t}\n";
						echo "\t\t\t}\n";
						echo "\t\t\treturn new _".$reflection->getName()."__Collection__Autogenerated_By_SaveableBuilder(\$cleanArray);\n";
						echo "\t\t}\n";
					}
				}
				echo "\t\t\n";
				echo "\t}\n";
				echo "?>";
				$handle = fopen(dirname($file)."/_".$reflection->getName()."__Collection__Autogenerated_By_SaveableBuilder.php", "w");
				fwrite($handle, ob_get_clean());
				fclose($handle);
				$classContents = file_get_contents($reflection->getFileName());
				$classContents = str_replace(
					"class ".$reflection->getName()." extends ".
							$extendingClass, 
					"class ".$reflection->getName()." extends /* ".$extendingClass." via */ _".
							$reflection->getName().
							"__Autogenerated_By_SaveableBuilder", 
					$classContents
				);
				$handle = fopen($reflection->getFileName(), "w");
				fwrite($handle, "<?php require_once(dirname(__FILE__).\"/_".$reflection->getName()."__Autogenerated_By_SaveableBuilder.php\"); ?>\n");
				fwrite($handle, $classContents);
				fclose($handle);
				echo "Built ".basename($reflection->getFileName())."\n";
			}
			else
			{
				echo "Skipping ".basename($reflection->getFileName())."\n";
				echo "\t'getTableDefinition' method doesn't return a TableDefinition object.";
			}
		}
		else
		{
			echo "Unbuilt ".basename($reflection->getFileName())."\n";
		}
	}

?>
